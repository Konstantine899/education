# webpack

[https://docs.google.com/presentation/d/19iWKO-sg3Ed94FLEU4KCpjR_jzRqwAA7gmkk5mTv6Js/edit?usp=sharing](https://docs.google.com/presentation/d/19iWKO-sg3Ed94FLEU4KCpjR_jzRqwAA7gmkk5mTv6Js/edit?usp=sharing)

[Юрий Бура Webpack конспект](https://github.com/Konstantine899/education/tree/master/react-theory/build__the__react__webpack__app)

[Юрий Бура Webpack Udemy](https://www.udemy.com/course/pro-react-redux/learn/lecture/13181648#overview)

[Юрий Бура Babel коспект](https://github.com/Konstantine899/education/tree/master/react-theory/build__the__react__babel__app)

[Юрий Бура Babel Udemy](https://www.udemy.com/course/pro-react-redux/learn/lecture/13181648#overview)

Если вы создаете с ноля проект то вы устанавливаете все пакеты последовательно. И вы можете работать уже в существующем проете. Обычно когда вы работаете в команде там уже есть шаблон стартовый либо уже идет проект и вы скачиваете его с Git и соответственно у вас есть package.json. Для того что бы инициализировать пакеты которые уже используются и для того что бы это все заработало мы набираем команду **npm i**.

У меня появился файл package-lock.json. Этот файл создается при установке модулей. Он обновляется. Его так же лучше не передавать никуда другим участникам команды, не заливать на git в том числе потому что он привязан к системе и могут быть ошибки. Если его удалить то ничего страшного не произойдет он все равно подтянется. Он именно локально нужен для npm для оптимизации его работы.

Рассмотрим

```json
"scripts": {
    "dev": "webpack-dev-server",
    "build": "webpack"
  },
```

Здесь сразу указаны команды которые будут запускаться. Мы можем их указать. Они запускаются с приставкой npm или npx. npx- это локальный запуск какого-то пакета. Так же мы можем запустить npm run dev или npm run build и соответственно запуститься соответствующая команда. Особенно если вы используете framework строки в данных командах могут быть существенно больше. Очень много приставок всяких флагов. Плюс эти скрипты могут запускаться непосредственно с каких-нибудь сервисов на которые вы будете заливать проект например с heroku. Там будет запускаться например npm установка всех пакетов. Потом могут запускаться какие-то соответствующие скрипты со списка скриптов для того что бы проект заработал и запустился на сервере.

Webpack - это сборщик. Сборщики предназначены для интеграции многих частей приложения в единое целое, а так же выполнение различных преобразований нашего кода и вспомогательных инструментов.

Например преобразование scss кода в css. Транспилирование ECMAScript в более старые версии для этого используется babel. Babel - это транспилятор который преобразует код из одного стандарта в другой стандарт. Например мы пишем const а в итоговом бандле это будет var. Так же он может минифицировать файлы. Проверять на ошибки, добавлять вендорные префиксы, создание спрайтов, генирацией каких-нибудь иконок и т.д.

webpack.config.js

```js
const path = require("path"); // модуль для работы с путями
const autoprefixer = require("autoprefixer"); // растановка вендорных префиксов в css для улучшения кросбраузерности
const precss = require("precss");
const HtmlWebpackPlugin = require("html-webpack-plugin"); // для работы с html файлами

module.exports = {
  // Итак,  чтобы вебпак начал свою работу, нужно указать главный (основной) файл, который будет включать в себя все другие необходимые файлы (модули).
  entry: {
    polyfill: "babel-polyfill", // эмуляция скриптов которые не могут быть транспилированы feth promise asinc await и т.д.
    app: "./js/app.js", // точка входа
    // app: ["babel-polyfill", "./js/app.js"], можно прописать в виде массива при этом поряжок важен
  },
  // Также webpack рекомендует явно указывать, в какой директории находятся исходные файлы проекта (ресурсы). Для этого следует использовать свойство context:
  context: path.resolve(__dirname, "src"), // дирректория исходных файлов проекта
  devServer: {
    publicPath: "/",
    port: 9000,
    contentBase: path.join(process.cwd(), "dist"),
    host: "localhost",
    historyApiFallback: true,
    noInfo: false,
    stats: "minimal",
    hot: true, // hotreload пререзагрузка при изменении сразу
  },
  module: {
    // Для того, чтобы трансформировать файл, используются специальные утилиты - загрузчики (loaders).
    //Для любых настроек модуля вебпак используется поле module.
    //Массив rules  внутри объекта module определяет список правил для загрузчиков.
    rules: [
      {
        use: {
          loader: "babel-loader",
          options: {
            presets: ["@babel/preset-env"], // все наборы правил по которым должен транспилироваться код 
          },
        },
        test: /\.js$/,
      },
      {
        test: /\.css$/,
        use: [
          {
            loader: "style-loader",
          },
          {
            loader: "css-loader",

            options: {
              importLoaders: 1,
              sourceMap: true,
            },
          },
          {
            loader: "postcss-loader",
            options: {
              plugins: () => [precss, autoprefixer],
            },
          },
        ],
      },
      {
        test: /\.(png|jpe?g|gif)$/,
        use: [
          {
            loader: "file-loader",
            options: {
              name: "[path][name].[ext]",
            },
          },
        ],
      },
    ],
  },
  // Вебпак плагины используются для настройки процесса сборки.
  //Например, плагин для минификации кода (во время сборки код подвергается очистке и минификации).
  //Или плагин для сборки html страницы и css кода (скрипты вставляются в html, куски css собираются в один файл).
  plugins: [
    new HtmlWebpackPlugin({
      template: "index.html",
    }),
  ],
  // Кроме entry, мы можем указать поле, куда (в какой файл) собирать конечный результат. Это свойство задаётся с помощью поля output.
  //По умолчанию, весь результирующий код собирается в папку dist.
  output: {
    path: path.resolve(__dirname, "dist"),
    filename: "[name].[hash].js",
  },
  mode: "development",
};
```


Кароче учиотдельно. Пример у Юрия Буры.