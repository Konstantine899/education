# Логические операторы

[https://docs.google.com/presentation/d/1jF-QOejhsn0TVsV1wCuxH7fqok0jll-Mb3OSiMhePBQ/edit?usp=sharing](https://docs.google.com/presentation/d/1jF-QOejhsn0TVsV1wCuxH7fqok0jll-Mb3OSiMhePBQ/edit?usp=sharing),

[https://learn.javascript.ru/comparison](https://learn.javascript.ru/comparison),

[https://learn.javascript.ru/ifelse](https://learn.javascript.ru/ifelse)

Операторы и конструкция if else.

В **JS**  существует несколько типов операторов. Это например арифметические операторы. Сейчас мы познакомимся с операторами сравнения и логическими операторами.

Операторы сравнения.

1. **\>** - оператор больше
2. **\<** - оператор меньше
3. **\>=** - больше либо равно
4. **\<=** - меньше либо равно
5.**==** - оператор не строгого равенства
6. **===** - оператор строгого равенства
7. **!=** - не строгое не равенство,
8. **!==** - строгое не равенство

```js
let value;

value = 1 > 2; // false
value = 1 <= 2; // true
value = 2 <= 2; // true

console.log(value);
```
Все эти операторы будут возвращать **true** или **false**.

Немного интересно становится с равенством.

```js
value = 1 == 1; // true
value = 1 == '1'; // true
```
Когда мы число проверяем со строкой 1 и '1' то это истина. Дело в том что не строгое равенство не проверяет на тип данных, то есть оно преобразовывает строку к числу.

```js
value = 1 == true; // true
```
так же будет true т.к. при преобразовании типов **true** равна 1.

Со строгим равенством непосредственно другая ситуация. 
```js
value = 1 === '1'; // false
```
Абсолютно все тоже самое с оператором неравенства

```js
value = 1 != '1'; // false
```
Он преобразует строку к числу, видит что они равны, соответсвенно то что они не равня является ложью.

А строгое не равенство вернет true так как они не равны.

```js
value = 1 !== '1'; // true
```
<br>
<br>
<br>
<br>

Так же при сравнении есть нюанс когда мы сравниваем строки.
Каждый символ строки имеет свое представление в формате unicode т.е. у каждого символа есть свое числовое представление.

```js
value = 'a' > 'a'; // false
```
В числовом представлении **unicode** 'a' и 'a' одинаковы, они долны быть равны.
```js
value = 'a' === 'a'; // true
```

Если я сравню данный символ в разных регистрах.

```js
value = 'a' > 'A'; // true
```
Это так же происходит из-за того что 'A' имеет меньший **unicode** чем 'a'.

Так же строки сравниваются по символьно.

```js
value = 'a' > 'ab'; // false
```
 Потому что в 'ab' больше символов.

 Для того что бы посмотреть к какому **unicode** относится тот или иной символ. У сивола необходимо вызывать метод **charCodeAt()** после чего вернется числовое значение.
 ```js
 value = 'a'.charCodeAt(); // 97
 ```
 Если возьмем 'A'
 ```js
 value = 'A'.charCodeAt(); // 65
 ```
 Таким образом мы можем сравнить строки, числа и т.д.

 <br>
 <br>
 <br>
 <br>

**Условия if else и операторы логические**
В любом языке программирования есть условия. Это ветвление кода в зависимосто от того что выбрал пользователь и сделал какое-то действие или нам пришли какие-то данные или что-то выщетали и мы хотим выполнить те или иные манипуляции т.е. в зависимости от какого-то условия мы будем выполнять какие-то действия.

Для этого есть несколько конструкций. C **if else** все очень просто.

```js
if (условие){
// actions
}else{
// else actions
}
```

Если в условии **if true** то действие в фигурных скобках выполнится, и **else** уже не выполнится. Если в **if false** то действие в фигурных скобках **if** не выполнится, а выполнится в **else**.

```js
value = 10;
if (value === 10) {
  console.log("value: 10");
} else {
  console.log("else");
}
```
![](img/001.png)

Иначе

```js
value = 10;
if (value !== 10) {
  console.log("value: 10");
} else {
  console.log("else");
}
```
![](img/002.png)

Так же можно просто проверить есть ли переменная.

```js
if (value) {
  console.log("some actions");
} else {
  console.log("else");
}
```
![](img/003.png)
Здесь подрозумевается что переменная есть, она не **undefined**, не **Null** и не пустая строка т.е. все эти значение преобразуются к **false**.

Если переменная **null** то условие уже не выполниться.

```js
value = null;

if (value) {
  console.log("some actions", value);
} else {
  console.log("else", value);
}
```
![](img/004.png)

**null** в булевом представлении преобразуется к **false**.

Если **value** будет пустой строкой.
```js
value = '';

if (value) {
  console.log("some actions", value);
} else {
  console.log("else", value);
}
```
![](img/005.png)

Если **value** Будет равно нулю, то тоже самое выполнится else со значением **0**.

```js
value = 0;

if (value) {
  console.log("some actions", value);
} else {
  console.log("else", value);
}
```
![](img/006.png)

NaN в булевом представлении так же **false**

```js
value = NaN;

if (value) {
  console.log("some actions", value);
} else {
  console.log("else", value);
}
```
![](img/007.png)

<br>
<br>
<br>

**Логические операторы.**
1. || - или
2. && - или
3. ! - не

```js
value = null;

console.log(!value); // true
```
Если поставить два !! мы преобразуем к исходному состоянию.
```js
value = null;

console.log(!!value); // true
```
Это очень часто делают для того что бы преобразовать не булево значение в булевое значение.

Проверка со сложными данными типа массива и объекта.
В **JS** пустой массив считается **true**

```js
value = [];

if (value) {
  console.log(value);
}
```
![](img/008.png)

Если нужно проверить есть ли что в массиве.
```js
value = [];

if (value.length) {
  console.log(value);
} else {
  console.log("array is empty");
}
```
![](img/009.png)

Ноль в булевом представлении это **false**, а массив у нас пустой.
Иногда нужно проверить что массив является массивом. Для этого использую специальную функцию **isArray()** в параметры которого передаю массив.

```js
value = [];

if (Array.isArray(value)) {
  console.log(value);
} else {
  console.log("array is empty");
}
```
![](img/010.png)

или же 

```js
value = null;

if (Array.isArray(value)) {
  console.log(value);
} else {
  console.log("array is empty");
}
```
![](img/011.png)

<br>
<br>
<br>
<br>

**Что касается объектов.**

Если в условии написать просто **name** а не **user.name**, то **name** при интерпритации он посчитает переменной. Этой переменной нет соответственно условие не выполнено. Мы ображаемся к объекту и после обращаюсь к его полю.

```js
let user = {
  name: "Konstantine",
};

if (user.name) {
  console.log(user.name);
} else {
  console.log("else");
}
```
![](img/012.png)


Еще одна проверка. У объекта **user** можно вызвать метод **hasOwnProperty()**, он возвращает **true** или **false**. В параметры он принимает в качестве значения имя ключа объекта.

```js
let user = {
  name: "Konstantine",
};

if (user.hasOwnProperty("name")) {
  console.log(user.name);
} else {
  console.log("else");
}
```

<br>
<br>
<br>

**Операторы || &&**

Достаточно запомнить что оператор **&&(и)** запинается на лжи, а оператор **||** запинается на правде. Оператор **&&** пытается преобразовать каждое значение к **false**, а оператор **||** каждое значение пытается преобразовать к **true**.

Что это значит?

```js
value = 1 || 0;
console.log(value); //возвращает 1
```
Как видим оператор **||** запинается на правде. Он пытается каждый из своих операндов преобразовать к **true**. И если оно преобразовывается то он возвращает **true**.

Оператор или по мимо условий часто используется в определении значений для переменной. Создаю переменную **let** **nikname**. Сервер может вернуть **nikname** а может вернуть например пустую строку, или вообще ни какое-значение. Такое может быть, например это поле было не обязательным при регистрации. Пользователь не запомнил его и все!!. Т.е. у нас есть воображаемый сервер **serverNikname = 'Konstantine';**
И есть переменная которую я буду использовать для вывода в разметку например.
Оператор **||** здесь очень удобен т.е. нужно проверить если есть переменная **serverNikname** то мы должны ее присвоить **nikname**. Если ее нет, то мы должны присвоить что-то другой. Для этого можно написать конструкцию **if else**, но можно сделать проще.

```js
let serverNikname = "Konstantine";
let nikname = serverNikname || "default nikname";
console.log(nikname);
```
 таким образом оператор или попытаеся это преобразовать к **true** т.е. если в переменной **serverNikname** есть значение то он ее вернет и запишет в **nikname**. Если нет, то он запишет **'default nikname'**.

 ![](img/013.png)

 Если по какой-то причине придет пустая строка
 ```js
 let serverNikname = "";
let nikname = serverNikname || "default nikname";
console.log(nikname);
 ```
 ![](img/014.png)

 <br>
 <br>
 <br>
 <br>

 **Оператор &&.**
 Оператор **&&** в отличие от оператора **||** запинается на лжи. Он всегда пытается вернуть **false**. Если ни одного **false** он не вернет, то он возвращает последнее **true**. Все в точности наоборот от **||**.

 ```js
 value = 1 && 0 && 3;
console.log(value);// возвращает 0
 ```
Так же если вместо **0** будет **false**, **null** и т.д то он вернет ложь.
 
 Пример.
 ```js
productPrice = 10;

if (productPrice >= 5 && productPrice <= 20) {
    console.log('Беру')
}else{
    console.log('else')
}
```
![](img/015.png)

т.е. две части условия должны быть правддивыми и тогда услови **if** выполнится.

<br>
<br>
<br>

**условие else if**
Это возможность сделать несколько проверок.

```js
value = 10;

if (value < 10) {
  console.log("value < 10", value);
} else if (value >= 10) {
  console.log("value >= 10", value);
} else {
  console.log("else");
}
```
![](img/016.png)